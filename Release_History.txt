Version 0.2.3
* Implementation of Act/Act ICMA added. This had some wider consequence. 
  Application of Act/Act ICMA requires additional parameters for calculating
  year fractions (time period and rolling date), which have been added as optional
  parameters to the year fraction method. Since Act/Act ICMA is only applicable 
  under certain conditions, the year fraction method can fail. Therefore, a 
  Result is returned instead of float. In turn, cash flow rollout may also 
  fail.
* Since the year fraction method returns now a Result it is also flagged 
  as an error, if some 30/x method is applied to the period of 30th to 31st
  of the same month, in which case the method is also not applicable. 

Version 0.2.2
* Cash flow type added
* Currency type added
* TimePeriodError and CouponDate Error are now enums rather than structs
* DayCountConv moved to a separate module
* Implementation of day count methods (except for act/act ICMA) with many test cases
* New utility module
* First simple version of cash flow rollout (without adjustments)

Version 0.2.1
* Data structure for bonds added with example reading data from JSON
* New types for day count conventions and business day adjustments
* NthWeedDay has been renamed to NthWeek (of month), which seems to be more appropriate
* Implementation of Serialization/Deserialization of TimePeriod

Version 0.2.0
* Replacement the SimpleCalendar and the Calendar trait by one Calendar struct. At
  initialization, the holiday calendar is computed for a range of year by specifying 
  a set of holiday rules. A very broad range of holiday calendars could be generated 
  this way. The method `is_holiday` returns true only for holidays, but not for
  weekends. There is another method `is_weekend` to check for that. The new
  method `is_business_day` checks wether the given date is neither a weekend nor 
  a holiday.

Version 0.1.3
* Implementation of TimerPeriod is no longer a trait, but a struct. The calendar 
  required for BusinessDaily time period is now an external parameter. This seems
  to be a better choice, since a calendar is more a parameter than part of a method.
  Calendars may also be subject to chance, though only rarely.
